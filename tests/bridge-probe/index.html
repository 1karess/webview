<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bridge Probe (Generic)</title>
  <style>
    body{font-family:system-ui;padding:16px;max-width:960px;margin:0 auto}
    .grid{display:grid;grid-template-columns:1fr;gap:12px}
    .card{border:1px solid #ddd;border-radius:8px;padding:12px}
    .ok{background:#e6ffed;border-color:#b7f5c6}
    .warn{background:#fff5f0;border-color:#ffd6cc}
    pre{background:#f6f8fa;padding:10px;border-radius:6px;white-space:pre-wrap}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    button{padding:8px 12px}
    code{background:#f0f3f6;padding:2px 6px;border-radius:4px}
  </style>
</head>
<body>
  <h1>Generic Bridge Probe</h1>
  <p>Open this page inside any in-app WebView to detect injected JS bridges or special objects. Then tap Run.</p>
  <div class="row">
    <button id="run">Run</button>
    <button id="copy">Copy JSON</button>
    <button id="safeGet">Safe GET (single)</button>
    <button id="multi">Multi-domain test</button>
    <a href="./oracle-leak.html" id="oracleLink" style="padding:8px 12px;border:1px solid #ddd;border-radius:6px;text-decoration:none;align-self:center">Oracle leak test →</a>
    <button id="oracleInline" title="Run oracle in-place (same WebView)">Run oracle inline</button>
    <a href="./index.html?oracle=1" id="oracleAuto" style="padding:8px 12px;border:1px solid #007acc;color:#007acc;border-radius:6px;text-decoration:none;align-self:center">Oracle inline (auto)</a>
    <input id="hook" placeholder="https://your-webhook" style="flex:1;min-width:220px;padding:8px" />
    <button id="send">Send to webhook</button>
    <button id="bridgePost">Bridge POST (httpbin)</button>
    <button id="readBody">Read body (httpbin)</button>
    <button id="authTest">Auth header test</button>
  </div>
  <div id="summary" class="card"></div>
  <div class="grid">
    <div class="card"><h3>Findings</h3><pre id="out">Ready.</pre></div>
    <div class="card"><h3>Raw</h3><pre id="raw"></pre></div>
    <div class="card">
      <h3>Custom request tester</h3>
      <div class="row" style="gap:6px">
        <select id="m" style="padding:8px">
          <option>GET</option>
          <option>POST</option>
        </select>
        <input id="u" placeholder="https://httpbin.org/get" style="flex:1;min-width:260px;padding:8px" />
      </div>
      <div class="row" style="margin-top:6px;gap:6px">
        <input id="h" placeholder="Header: X-Test=1; Accept=*/*" style="flex:1;min-width:260px;padding:8px" />
      </div>
      <div class="row" style="margin-top:6px;gap:6px">
        <textarea id="b" placeholder="Body (for POST)" style="flex:1;min-height:80px;padding:8px"></textarea>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="sendReq">Send</button>
      </div>
      <pre id="reqOut" style="margin-top:8px"></pre>
    </div>
  </div>
<script>
(function(){
  // autorun inline oracle if ?oracle=1
  (function(){
    try{
      const p = new URLSearchParams(location.search);
      if (p.get('oracle')==='1'){ setTimeout(()=>{ document.getElementById('oracleInline').click(); }, 300); }
    }catch{}
  })();
  const out = document.getElementById('out');
  const raw = document.getElementById('raw');
  const summary = document.getElementById('summary');
  const results = { runs: [] };
  const patterns = [
    /telegram|tg|webapp/i,
    /bridge|native|app|sdk|jsi|webview/i,
  ];
  function looksSuspicious(name, value){
    if (!name) return false;
    if (patterns.some(p=>p.test(name))) return true;
    if (value && typeof value === 'object'){
      const s = Object.keys(value).join(',');
      if (/bridge|native|invoke|postMessage|sdk/i.test(s)) return true;
    }
    return false;
  }
  function safeCall(fn){
    try{ const r = fn(); return { ok:true, value: String(r).slice(0,200) }; }
    catch(e){ return { ok:false, error: String(e.message||e).slice(0,200) }; }
  }
  function probe(){
    const t0 = performance.now();
    const findings = [];
    const seen = new Set();
    const known = {
      hasTelegramWebApp: !!(window.Telegram && window.Telegram.WebApp),
      hasTelegramWebview: !!window.TelegramWebview,
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      time: new Date().toISOString(),
    };
    for (const k in window){
      if (seen.has(k)) continue; seen.add(k);
      let v; try{ v = window[k]; }catch{ v = undefined; }
      const sus = looksSuspicious(k, v);
      if (!sus) continue;
      const entry = { name:k, type: typeof v };
      if (typeof v === 'function'){
        entry.sample = safeCall(()=>v());
      } else if (v && typeof v === 'object'){
        const keys = Object.keys(v).slice(0,8);
        entry.keys = keys;
        for (const m of keys){
          if (typeof v[m] === 'function'){
            entry.call = { method:m, result: safeCall(()=>v[m]()) };
            break;
          }
        }
      }
      findings.push(entry);
      if (findings.length>=100) break;
    }
    const t1 = performance.now();
    const report = { known, findings, durationMs: +(t1-t0).toFixed(2) };
    results.runs.push({ type:'probe', report });
    return report;
  }
  let last = null;
  document.getElementById('run').onclick = ()=>{
    last = probe();
    const count = last.findings.length;
    summary.className = 'card ' + (count>0 ? 'warn' : 'ok');
    summary.innerHTML = count>0
      ? `Possible bridges found: <strong>${count}</strong> (review carefully)`
      : `No obvious bridges detected.`;
    out.textContent = last.findings.map((f,i)=>`${i+1}. ${f.name} [${f.type}]` + (f.keys?`\n   keys: ${f.keys.join(', ')}`:'') + (f.call?`\n   call: ${f.call.method} -> ${JSON.stringify(f.call.result)}`:'' )).join('\n\n') || 'None';
    raw.textContent = JSON.stringify(last, null, 2);
    // Auto-run inline oracle right after probe to stay in the same WebView
    try{ setTimeout(()=>window.runOracleInline && window.runOracleInline(), 300); }catch{}
  };
  async function tryBridgeGet(url){
    const out = { url };
    try{
      if (typeof window.TXWebKitNativeFetch === 'function'){
        const p = window.TXWebKitNativeFetch(url);
        const val = await Promise.race([
          Promise.resolve(p).then(()=>"ok"),
          new Promise((_,rej)=>setTimeout(()=>rej(new Error('timeout')), 5000))
        ]);
        out.via = 'TXWebKitNativeFetch';
        out.result = val;
      } else {
        const r = await Promise.race([
          fetch(url, { mode:'no-cors', cache:'no-store', credentials:'omit' }).then(()=>"ok"),
          new Promise((_,rej)=>setTimeout(()=>rej(new Error('timeout')), 5000))
        ]);
        out.via = 'fetch';
        out.result = r;
      }
    }catch(e){
      out.error = String(e.message||e);
    }
    return out;
  }
  function pushRaw(obj){
    const merged = Object.assign({}, last||{}, { extra: (last&&last.extra)||[] });
    merged.extra = merged.extra || [];
    merged.extra.push(obj);
    last = merged;
    raw.textContent = JSON.stringify(last, null, 2);
  }
  document.getElementById('safeGet').onclick = async ()=>{
    const url = 'https://www.cloudflare.com/cdn-cgi/trace';
    const res = await tryBridgeGet(url);
    summary.className = 'card';
    summary.innerHTML = `Safe GET → ${url}<br>via: <code>${res.via||'-'}</code> result: <code>${res.result||'-'}</code> ${res.error?`error: <code>${res.error}</code>`:''}`;
    pushRaw({ type:'safe-get', res });
  };
  document.getElementById('multi').onclick = async ()=>{
    const urls = [
      'https://example.com/favicon.ico',
      'https://www.cloudflare.com/cdn-cgi/trace',
      location.origin + '/index.html'
    ];
    const outAll = [];
    for (const u of urls){ outAll.push(await tryBridgeGet(u)); }
    const lines = outAll.map(o=>`${o.url} → ${o.via||'-'} ${o.result||o.error||'-'}`).join('\n');
    out.textContent = lines;
    pushRaw({ type:'multi-domain', results: outAll });
  };
  function parseHeaders(s){
    const o = {};
    (s||'').split(';').map(x=>x.trim()).filter(Boolean).forEach(kv=>{
      const i = kv.indexOf('=');
      if (i>0){ const k = kv.slice(0,i).trim(); const v = kv.slice(i+1).trim(); if (k) o[k]=v; }
    });
    return o;
  }
  document.getElementById('sendReq').onclick = async ()=>{
    const reqOut = document.getElementById('reqOut');
    const method = document.getElementById('m').value;
    const url = (document.getElementById('u').value||'').trim();
    const headers = parseHeaders(document.getElementById('h').value||'');
    const body = document.getElementById('b').value||'';
    if (!url) { reqOut.textContent = 'Enter URL'; return; }
    const info = { type:'custom-request', url, method, headersPresent: Object.keys(headers).length>0, bodyBytes: body.length };
    try{
      if (typeof window.TXWebKitNativeFetch === 'function' && method==='GET' && !body){
        const p = window.TXWebKitNativeFetch(url);
        await Promise.race([Promise.resolve(p), new Promise((_,r)=>setTimeout(()=>r(new Error('timeout')),6000))]);
        info.via = 'TXWebKitNativeFetch';
        info.result = 'ok';
      } else {
        const init = { method, mode:'no-cors', cache:'no-store', credentials:'omit', headers };
        if (method==='POST') init.body = body;
        await Promise.race([fetch(url, init), new Promise((_,r)=>setTimeout(()=>r(new Error('timeout')),6000))]);
        info.via = 'fetch';
        info.result = 'ok';
      }
    }catch(e){ info.error = String(e.message||e); }
    pushRaw(info);
    reqOut.textContent = JSON.stringify(info, null, 2);
  };
  document.getElementById('send').onclick = async ()=>{
    try{
      const url = (document.getElementById('hook').value||'').trim();
      if (!url) return alert('Enter webhook URL');
      const payload = last || { note:'no run yet' };
      const resp = await fetch(url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
      summary.className = 'card';
      summary.innerHTML = `Webhook status: <code>${resp.status}</code>`;
    }catch(e){
      summary.className = 'card';
      summary.innerHTML = `Webhook error: <code>${String(e.message||e)}</code>`;
    }
  };
  document.getElementById('bridgePost').onclick = async ()=>{
    const info = { type:'bridge-post', url:'https://httpbin.org/post', method:'POST', headers:{'X-Test':'bridge'}, body:'{"msg":"hello_bridge"}' };
    try{
      if (typeof window.TXWebKitNativeFetch !== 'function') throw new Error('TXWebKitNativeFetch not found');
      const p = window.TXWebKitNativeFetch(info.url, { method:'POST', headers: info.headers, body: info.body });
      await Promise.race([Promise.resolve(p), new Promise((_,r)=>setTimeout(()=>r(new Error('timeout')),6000))]);
      info.via = 'TXWebKitNativeFetch';
      info.result = 'ok';
    }catch(e){ info.error = String(e.message||e); }
    pushRaw(info);
    summary.className = 'card';
    summary.innerHTML = `Bridge POST → ${info.url} result: <code>${info.result||info.error||'-'}</code>`;
  };
  document.getElementById('readBody').onclick = async ()=>{
    const info = { type:'read-body', url:'https://httpbin.org/anything' };
    try{
      let status = null, bodySnippet = null, via = null;
      if (typeof window.TXWebKitNativeFetch === 'function'){
        const r = await Promise.race([
          Promise.resolve(window.TXWebKitNativeFetch(info.url)),
          new Promise((_,r)=>setTimeout(()=>r(new Error('timeout')),7000))
        ]);
        // Best-effort: if bridge returns Response-like
        if (r && typeof r === 'object'){
          if (typeof r.status === 'number') status = r.status;
          if (typeof r.text === 'function'){
            try{ const t = await r.text(); bodySnippet = String(t).slice(0,500); }catch{}
          }
        }
        via = 'TXWebKitNativeFetch';
      }
      // Fallback to fetch (CORS-enabled endpoint)
      if (bodySnippet==null){
        const fr = await fetch(info.url, { mode:'cors', cache:'no-store', credentials:'omit' });
        status = fr.status; const t = await fr.text(); bodySnippet = t.slice(0,500); via = via || 'fetch';
      }
      info.via = via; info.status = status; info.bodySnippet = bodySnippet;
      summary.className = 'card';
      summary.innerHTML = `Read body → ${info.url}<br>via: <code>${via}</code> status: <code>${status}</code>`;
    }catch(e){ info.error = String(e.message||e); }
    pushRaw(info);
  };
  document.getElementById('authTest').onclick = async ()=>{
    const info = { type:'auth-test', url:'https://httpbin.org/anything', headers:{ 'Authorization':'Bearer TEST' } };
    try{
      // Cookie header cannot be set by JS (forbidden header). We record that policy.
      const init = { method:'GET', mode:'cors', cache:'no-store', credentials:'omit', headers: info.headers };
      const fr = await fetch(info.url, init);
      info.status = fr.status;
      const txt = await fr.text();
      info.bodySnippet = txt.slice(0,500);
      info.note = 'Cookie header cannot be set by JS; use Set-Cookie or server to test cookies.';
      summary.className='card';
      summary.innerHTML = `Auth test → sent Authorization: Bearer TEST, status: <code>${info.status}</code>`;
    }catch(e){ info.error = String(e.message||e); }
    pushRaw(info);
  };
  document.getElementById('copy').onclick = ()=>{
    const text = raw.textContent || 'No data';
    navigator.clipboard.writeText(text).then(()=>{ alert('Copied'); });
  };

  // Minimal in-place Oracle runner to stay in the SAME WebView instance
  async function runOracleInline(){
    const targets = [
      'https://httpbin.org/status/401',
      'https://httpbin.org/status/403',
      'https://httpbin.org/anything'
    ];
    function withTimeout(promise, ms){
      return Promise.race([
        Promise.resolve(promise),
        new Promise((_,rej)=>setTimeout(()=>rej(new Error('timeout')), ms))
      ]);
    }
    function getBridges(){
      const bridges = [];
      if (typeof window.TXWebKitNativeFetch === 'function'){
        bridges.push({ name:'TXWebKitNativeFetch', fn: (url, init)=>window.TXWebKitNativeFetch(url, init) });
      }
      if (window.TelegramWebview && typeof window.TelegramWebview.nativeFetch === 'function'){
        bridges.push({ name:'TelegramWebview.nativeFetch', fn: (url, init)=>window.TelegramWebview.nativeFetch(url, init) });
      }
      const hasByteInvoke = window.byted_mixrender_native && typeof window.byted_mixrender_native.invoke === 'function';
      const hasJS2 = window.JS2NativeBridge && typeof window.JS2NativeBridge._invokeMethod === 'function';
      const hasBDX = window.BDXBridge && typeof window.BDXBridge._invokeMethod === 'function';
      function toByteReq(url){ return { url, method:'GET', headers:{}, body:'' }; }
      function wrap(invoke, method){
        return (url)=>new Promise((resolve,reject)=>{
          const opt = toByteReq(url); let done=false; const t=setTimeout(()=>{ if(!done){done=true;reject(new Error('timeout'));}},6000);
          const cb=(resp)=>{ if(done) return; done=true; clearTimeout(t); try{ resolve(typeof resp==='string'?JSON.parse(resp):resp);}catch(e){ resolve({ error:String(e&&e.message||e) }); } };
          try{ if (method) invoke(method, opt, cb); else invoke(opt, cb); }catch(e){ if(!done){done=true;clearTimeout(t);reject(e);} }
        });
      }
      if (hasByteInvoke) bridges.push({ name:'byted_mixrender_native.invoke', fn: wrap(window.byted_mixrender_native.invoke.bind(window.byted_mixrender_native), 'request') });
      if (hasJS2) bridges.push({ name:'JS2NativeBridge._invokeMethod', fn: wrap(window.JS2NativeBridge._invokeMethod.bind(window.JS2NativeBridge), 'request') });
      if (hasBDX) bridges.push({ name:'BDXBridge._invokeMethod', fn: wrap(window.BDXBridge._invokeMethod.bind(window.BDXBridge), 'request') });
      return bridges;
    }
    async function tryFetch(url){
      try{
        const r = await withTimeout(fetch(url, { mode:'cors', credentials:'omit', cache:'no-store' }), 6000);
        return { via:'fetch', status:r.status, ok:r.ok };
      }catch(e){ return { via:'fetch', error: String(e&&e.message||e) }; }
    }
    async function tryBridge(b, url){
      try{
        const r = await withTimeout(b.fn(url, { method:'GET' }), 6000);
        const out = { via:b.name };
        if (r && typeof r==='object'){
          if (typeof r.status==='number') out.status=r.status;
          if (typeof r.ok==='boolean') out.ok=r.ok;
          if (typeof r.body==='string') out.bodySnippet=r.body.slice(0,120);
          if (typeof r.code!=='undefined') out.errorCode=r.code;
        }
        return out;
      }catch(e){ return { via:b.name, error:String(e&&e.message||e) }; }
    }
    const bridges = getBridges();
    const events = [];
    for (const u of targets){
      for (const b of bridges){ events.push(await tryBridge(b,u)); }
      events.push(await tryFetch(u));
    }
    const lines = events.map(e=>`${e.via} ${e.status||e.error||''}`);
    out.textContent = lines.join('\n') || 'None';
    raw.textContent = JSON.stringify({ inlineOracle:true, bridges:bridges.map(b=>b.name), events }, null, 2);
    try{ summary.className='card'; summary.innerHTML = `Inline oracle ran with <code>${bridges.length}</code> bridge(s).`; }catch{}
  }
  // expose globally to avoid scoping issues
  window.runOracleInline = runOracleInline;
  document.getElementById('oracleInline').onclick = window.runOracleInline;
})();
</script>
</body>
</html>
