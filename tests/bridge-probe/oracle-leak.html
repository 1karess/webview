<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bridge Oracle XS-Leaks</title>
  <style>
    body{font-family:system-ui;padding:16px;max-width:960px;margin:0 auto}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    .card{border:1px solid #ddd;border-radius:8px;padding:12px}
    .ok{background:#e6ffed;border-color:#b7f5c6}
    .warn{background:#fff5f0;border-color:#ffd6cc}
    pre{background:#f6f8fa;padding:10px;border-radius:6px;white-space:pre-wrap}
    code{background:#f0f3f6;padding:2px 6px;border-radius:4px}
    textarea{width:100%;min-height:120px}
    small{color:#666}
    .hidden{display:none}
    button{touch-action:manipulation}
    *{ -webkit-tap-highlight-color: rgba(0,0,0,0); }
  </style>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' https: data: blob:; script-src 'self' 'unsafe-inline'; connect-src *; img-src * data: blob:; style-src 'unsafe-inline' 'self'">
</head>
<body>
  <a href="./index.html" id="backLink">← Back</a>
  <h1 id="title">Bridge Oracle XS-Leaks</h1>
  <p><strong>测试目的：</strong>对比 Bridge 和 fetch() 访问同一 URL，看 Bridge 是否泄露更多信息（如用户登录状态、权限等级）。</p>

  <div class="card">
    <h3 style="margin-top:0">1. 配置测试目标</h3>
    <div style="margin-top:8px">
      <label><strong>测试目标 URL（每行一个）</strong></label>
      <textarea id="targets" style="min-height:100px">https://httpbin.org/status/401
https://httpbin.org/status/403
https://httpbin.org/anything</textarea>
      <small style="color:#666">输入你想测试的 URL。工具会用 Bridge 和 fetch() 同时访问这些 URL，然后对比返回结果。</small>
    </div>
  </div>

  <div class="card">
    <h3 style="margin-top:0">2. 运行测试</h3>
    <div class="row">
      <button id="run">▶ 运行测试</button>
      <button id="copy">📋 复制结果</button>
    </div>
    <div style="margin-top:8px">
      <label><input type="checkbox" id="includeFetch" checked /> <strong>同时测试 fetch() 基线</strong></label>
      <small style="display:block;color:#666;margin-top:4px">勾选后会用 fetch() 也访问一遍，用于对比。建议勾选。</small>
    </div>
    <div id="statusMsg" style="margin-top:8px;padding:8px;background:#f0f0f0;border-radius:4px;display:none"></div>
  </div>

  <div class="card hidden" id="advancedCard">
    <details>
      <summary style="cursor:pointer;font-weight:bold">高级选项（通常不需要）</summary>
      <div style="margin-top:8px">
        <label><input type="checkbox" id="gesture" /> 模拟用户手势</label>
        <small style="display:block;color:#666">某些 Bridge 需要用户点击后才能调用。</small>
      </div>
      <div style="margin-top:8px">
        <label><strong>超时时间（毫秒）</strong></label>
        <input id="timeoutMs" type="number" min="100" value="6000" style="padding:8px;width:160px;margin-top:4px" />
      </div>
      <div style="margin-top:8px" id="controlsInit">
        <label><strong>自定义请求头（JSON，可选）</strong></label>
        <textarea id="initJson" style="min-height:80px">{
  "method": "GET",
  "headers": {
    "X-Test": "1"
  },
  "body": ""
}</textarea>
      </div>
    </details>
  </div>

  <div id="summary" class="card" style="display:none"></div>

  <div class="card">
    <h3 style="margin-top:0">3. 测试结果</h3>
    <div style="margin-bottom:12px">
      <strong>简要结果：</strong>
      <pre id="out" style="background:#f6f8fa;padding:10px;border-radius:6px;white-space:pre-wrap;min-height:60px">等待运行测试...</pre>
    </div>
    <details>
      <summary style="cursor:pointer;font-weight:bold;margin-bottom:8px">📄 完整 JSON 结果（点击展开）</summary>
      <pre id="raw" style="background:#f6f8fa;padding:10px;border-radius:6px;white-space:pre-wrap;max-height:400px;overflow:auto">等待运行测试...</pre>
    </details>
  </div>

<script>
(function(){
  const raw = document.getElementById('raw');
  const out = document.getElementById('out');
  const summary = document.getElementById('summary');
  const statusMsg = document.getElementById('statusMsg');
  const results = { runs: [] };

  function now(){ return performance.now(); }
  function withTimeout(promise, ms){
    return Promise.race([
      Promise.resolve(promise),
      new Promise((_,rej)=>setTimeout(()=>rej(new Error('timeout')), ms))
    ]);
  }

  function getBridges(){
    const bridges = [];
    if (typeof window.TXWebKitNativeFetch === 'function'){
      bridges.push({ name:'TXWebKitNativeFetch', fn: (url, init)=>window.TXWebKitNativeFetch(url, init) });
    }
    if (window.TelegramWebview && typeof window.TelegramWebview.nativeFetch === 'function'){
      bridges.push({ name:'TelegramWebview.nativeFetch', fn: (url, init)=>window.TelegramWebview.nativeFetch(url, init) });
    }
    // ByteDance-style bridges (experimental): byted_mixrender_native / JS2NativeBridge / BDXBridge
    // We wrap callback-style APIs into a Promise and normalize a Response-like shape when possible
    const hasByteInvoke = window.byted_mixrender_native && typeof window.byted_mixrender_native.invoke === 'function';
    const hasJS2 = window.JS2NativeBridge && typeof window.JS2NativeBridge._invokeMethod === 'function';
    const hasBDX = window.BDXBridge && typeof window.BDXBridge._invokeMethod === 'function';

    function toByteRequestOptions(url, init){
      const method = (init && init.method) || 'GET';
      const headers = (init && init.headers) || {};
      const body = (init && init.body) || '';
      return { url, method, headers, body };
    }
    function wrapCallbackStyle(invokeFn, methodName){
      return (url, init)=>new Promise((resolve, reject)=>{
        const opt = toByteRequestOptions(url, init);
        try{
          const cb = (resp)=>{
            try{
              const r = (typeof resp === 'string') ? JSON.parse(resp) : resp;
              resolve(r);
            }catch(e){
              reject(new Error(`Callback JSON parse error: ${e && e.message || e}`));
            }
          };
          if (methodName){ invokeFn(methodName, opt, cb); }
          else { invokeFn(opt, cb); }
        }catch(e){ reject(e); }
      });
    }
    if (hasByteInvoke){
      bridges.push({ name:'byted_mixrender_native.invoke', fn: wrapCallbackStyle(window.byted_mixrender_native.invoke.bind(window.byted_mixrender_native), 'request') });
    }
    if (hasJS2){
      bridges.push({ name:'JS2NativeBridge._invokeMethod', fn: wrapCallbackStyle(window.JS2NativeBridge._invokeMethod.bind(window.JS2NativeBridge), 'request') });
    }
    if (hasBDX){
      bridges.push({ name:'BDXBridge._invokeMethod', fn: wrapCallbackStyle(window.BDXBridge._invokeMethod.bind(window.BDXBridge), 'request') });
    }
    return bridges;
  }

  async function tryOne(method, url, init, timeout){
    const t0 = now();
    const info = { method:method.name, url, startMs: t0 };
    try{
      const r = await withTimeout(method.fn(url, init), timeout);
      info.elapsedMs = +(now()-t0).toFixed(1);
      info.fulfilled = true;
      if (r && typeof r === 'object'){
        if (typeof r.status === 'number') info.status = r.status;
        if (typeof r.ok === 'boolean') info.ok = r.ok;
        if (typeof r.headers === 'object' && r.headers){
          try{
            const hs = (typeof r.headers?.forEach === 'function') ? (()=>{ const o={}; r.headers.forEach((v,k)=>o[k]=String(v)); return o; })() : r.headers;
            info.headers = hs;
          }catch{}
        }
        if (typeof r.text === 'function'){
          try{ const t = await r.text(); info.bodySnippet = String(t).slice(0,300); }catch{}
        } else if (typeof r.body === 'string') {
          info.bodySnippet = r.body.slice(0,300);
        } else if (typeof r.data === 'string') {
          info.bodySnippet = r.data.slice(0,300);
        }
      } else {
        info.resultType = typeof r;
        if (r !== undefined) info.resultPreview = String(r).slice(0,120);
      }
    }catch(e){
      info.elapsedMs = +(now()-t0).toFixed(1);
      info.fulfilled = false;
      info.error = String(e && (e.message||e)).slice(0,300);
      if (e && typeof e === 'object'){
        if (typeof e.code !== 'undefined') info.errorCode = e.code;
        if (typeof e.status === 'number') info.status = e.status;
        if (typeof e.reason === 'string') info.reason = e.reason.slice(0,200);
      }
    }
    return info;
  }

  async function tryFetchBaseline(url, timeout){
    const t0 = now();
    const info = { method:'fetch', url, startMs: t0 };
    try{
      const init = buildFetchInit();
      const fr = await withTimeout(fetch(url, init), timeout);
      info.elapsedMs = +(now()-t0).toFixed(1);
      info.fulfilled = true;
      info.status = fr.status;
      info.ok = fr.ok;
      try{ const txt = await fr.text(); info.bodySnippet = txt.slice(0,200); }catch{}
    }catch(e){
      info.elapsedMs = +(now()-t0).toFixed(1);
      info.fulfilled = false;
      info.error = String(e && (e.message||e)).slice(0,200);
    }
    return info;
  }

  function parseInitJson(){
    const txt = document.getElementById('initJson').value || '';
    let out = { method:'GET' };
    try{
      const o = JSON.parse(txt);
      const method = String((o.method||'GET')).toUpperCase();
      out.method = (method === 'POST') ? 'POST' : 'GET';
      if (o.headers && typeof o.headers === 'object') out.headers = o.headers;
      if (out.method === 'POST' && typeof o.body === 'string') out.body = o.body;
    }catch{}
    return out;
  }

  function buildFetchInit(){
    const creds = document.getElementById('fetchCreds').value || 'omit';
    const mode = document.getElementById('fetchMode').value || 'cors';
    const base = parseInitJson();
    const init = { method: base.method, mode, credentials: creds, cache:'no-store' };
    if (base.headers) init.headers = base.headers;
    if (base.method === 'POST' && typeof base.body === 'string') init.body = base.body;
    return init;
  }

  function classifyLeak(event){
    const sig = { oracle:false, reasons:[] };
    if (event.method !== 'fetch' && event.fulfilled) {
      if (typeof event.status === 'number' || typeof event.bodySnippet === 'string'){
        sig.oracle = true; sig.reasons.push('bridge returned status/body');
      }
    }
    if (!event.fulfilled && event.error){
      if (/AUTH|TOKEN|CSRF|LOGIN|DENY|forbidden|unauthor/i.test(event.error)){
        sig.oracle = true; sig.reasons.push('bridge error mentions auth/state');
      }
    }
    if (typeof event.errorCode !== 'undefined'){
      sig.oracle = true; sig.reasons.push('bridge error code present');
    }
    return sig;
  }

  function summarize(all){
    const byUrl = {};
    for (const e of all){
      byUrl[e.url] = byUrl[e.url] || { url:e.url, total:0, oracle:0 };
      byUrl[e.url].total++;
      const c = classifyLeak(e);
      if (c.oracle) byUrl[e.url].oracle++;
    }
    const list = Object.values(byUrl);
    const oracleAny = list.some(x=>x.oracle>0);
    return { oracleAny, urls:list };
  }

  function pushRaw(obj){
    const merged = Object.assign({}, results.last||{}, { extra:(results.last&&results.last.extra)||[] });
    merged.extra = merged.extra || [];
    merged.extra.push(obj);
    results.last = merged;
    raw.textContent = JSON.stringify(results.last, null, 2);
  }

  function parseParams(){
    const p = new URLSearchParams(location.search);
    const targetsParam = p.get('targets');
    const fetchParam = p.get('fetch');
    const gestureParam = p.get('gesture');
    const timeoutParam = p.get('timeout');
    const simple = p.get('simple');
    const autorun = p.get('autorun');
    if (targetsParam){
      try{
        const list = targetsParam.split(',').map(s=>decodeURIComponent(s.trim())).filter(Boolean);
        if (list.length){ document.getElementById('targets').value = list.join('\n'); }
      }catch{}
    }
    if (fetchParam!=null){ document.getElementById('includeFetch').checked = fetchParam==='1' || /true/i.test(fetchParam); }
    if (gestureParam!=null){ document.getElementById('gesture').checked = gestureParam==='1' || /true/i.test(gestureParam); }
    if (timeoutParam){ const n = parseInt(timeoutParam,10); if (!Number.isNaN(n) && n>0) document.getElementById('timeoutMs').value = n; }

    // Simple mode hides most controls for embedded/overlay environments
    if (simple && (simple==='1' || /true/i.test(simple))){
      document.getElementById('backLink').classList.add('hidden');
      document.getElementById('advancedCard').classList.add('hidden');
      document.getElementById('title').textContent = 'Bridge Oracle (Simple)';
    }

    // Autorun after params applied
    if (autorun && (autorun==='1' || /true/i.test(autorun))){
      setTimeout(()=>{ const btn = document.getElementById('run'); if (btn) btn.click(); }, 500);
    }
  }

  async function run(){
    if (!statusMsg) return;
    statusMsg.style.display = 'block';
    statusMsg.textContent = '⏳ 正在运行测试，请稍候...';
    out.textContent = '正在运行测试...';
    raw.textContent = '正在运行测试...';

    const timeout = Math.max(100, parseInt(document.getElementById('timeoutMs').value||'6000',10));
    const includeFetch = document.getElementById('includeFetch').checked;
    const isGesture = document.getElementById('gesture').checked;
    const urls = (document.getElementById('targets').value||'')
      .split(/\n+/).map(s=>s.trim()).filter(Boolean);

    if (urls.length === 0) {
      statusMsg.textContent = '❌ 错误：请至少输入一个测试目标 URL';
      statusMsg.style.background = '#fff5f0';
      return;
    }

    const bridges = getBridges();
    statusMsg.textContent = `🔍 找到 ${bridges.length} 个 Bridge，正在测试 ${urls.length} 个目标...`;

    const runMeta = { time:new Date().toISOString(), ua:navigator.userAgent, bridges:bridges.map(b=>b.name), timeout, includeFetch, isGesture };
    const events = [];

    async function execForUrl(u, idx, total){
      statusMsg.textContent = `⏳ 测试中... (${idx+1}/${total}): ${u}`;
      const parsed = parseInitJson();
      const init = { method: parsed.method };
      if (parsed.headers) init.headers = parsed.headers;
      if (parsed.method === 'POST' && typeof parsed.body === 'string') init.body = parsed.body;
      if (isGesture) { try{ document.body.click(); }catch{} }
      for (const b of bridges){
        events.push(await tryOne(b, u, init, timeout));
      }
      if (includeFetch) events.push(await tryFetchBaseline(u, timeout));
    }

    for (let i = 0; i < urls.length; i++){
      await execForUrl(urls[i], i, urls.length);
    }

    const report = { type:'oracle-leak', meta: runMeta, events, summary: summarize(events) };
    results.runs.push(report); results.last = report;

    const lines = [];
    for (const e of events){
      const tag = (e.fulfilled? '✅ OK' : '❌ ERR');
      const leak = classifyLeak(e);
      lines.push(`${tag} ${e.method} ${e.url} (${e.elapsedMs}ms)` + (leak.oracle? ` ⚠️ [泄露信号: ${leak.reasons.join(', ')}]` : ''));
    }
    out.textContent = lines.join('\n') || '无结果';

    const any = report.summary.oracleAny;
    if (any) {
      statusMsg.style.background = '#fff5f0';
      statusMsg.textContent = `⚠️ 检测到泄露信号！在 ${report.summary.urls.filter(x=>x.oracle>0).length} 个目标中发现 Bridge 比 fetch() 泄露了更多信息。`;
    } else {
      statusMsg.style.background = '#e6ffed';
      statusMsg.textContent = `✅ 测试完成。未发现明显的泄露信号（Bridge 和 fetch() 返回的信息量相近）。`;
    }

    summary.style.display = 'block';
    summary.className = 'card ' + (any ? 'warn' : 'ok');
    summary.innerHTML = any
      ? `<strong>⚠️ 发现泄露信号</strong><br>在 <strong>${report.summary.urls.filter(x=>x.oracle>0).length}</strong> 个目标中发现 Bridge 比 fetch() 泄露了更多信息（如状态码、错误信息、响应内容）。`
      : `<strong>✅ 未发现泄露信号</strong><br>Bridge 和 fetch() 返回的信息量相近。`;
    raw.textContent = JSON.stringify(report, null, 2);
  }

  // Improve touch responsiveness
  const runBtn = document.getElementById('run');
  runBtn.addEventListener('click', run, { passive:true });
  runBtn.addEventListener('touchstart', (e)=>{ e.preventDefault(); run(); }, { passive:false });
  document.getElementById('copy').onclick = ()=>{
    const text = raw.textContent || 'No data';
    navigator.clipboard.writeText(text).then(()=>{ alert('已复制到剪贴板'); });
  };

  parseParams();
})();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bridge Oracle XS-Leaks</title>
  <style>
    body{font-family:system-ui;padding:16px;max-width:960px;margin:0 auto}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    .card{border:1px solid #ddd;border-radius:8px;padding:12px}
    .ok{background:#e6ffed;border-color:#b7f5c6}
    .warn{background:#fff5f0;border-color:#ffd6cc}
    pre{background:#f6f8fa;padding:10px;border-radius:6px;white-space:pre-wrap}
    code{background:#f0f3f6;padding:2px 6px;border-radius:4px}
    textarea{width:100%;min-height:120px}
    small{color:#666}
  </style>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' https: data: blob:; connect-src *; img-src * data: blob:; style-src 'unsafe-inline' 'self'"> 
</head>
<body>
  <a href="./index.html">← Back</a>
  <h1>Bridge Oracle XS-Leaks</h1>
  <p>Evaluate whether native bridge methods act as a high-bandwidth oracle for cross-origin state.</p>

  <div class="card">
    <div class="row">
      <button id="run">Run matrix</button>
      <button id="copy">Copy JSON</button>
      <label><input type="checkbox" id="includeFetch" checked /> Also test fetch() baseline</label>
      <label><input type="checkbox" id="gesture" /> Simulate user gesture</label>
    </div>
    <div class="row" style="margin-top:8px">
      <input id="timeoutMs" type="number" min="100" value="6000" style="padding:8px;width:160px" />
      <small>Timeout (ms)</small>
    </div>
    <div style="margin-top:8px">
      <label><strong>Targets (one per line)</strong></label>
      <textarea id="targets">https://httpbin.org/status/401
https://httpbin.org/status/403
https://httpbin.org/anything
https://example.com/favicon.ico
data:text/plain,hello
about:blank</textarea>
      <small>Replace with internal/cross-origin endpoints relevant to the host app (e.g., https://internal.api/profile)</small>
    </div>
  </div>


